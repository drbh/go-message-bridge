package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
	"github.com/nlopes/slack"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"os/user"

	// "regexp"
	"bytes"
	"strconv"
	"strings"
	"time"

	"net/http"

	"github.com/boltdb/bolt"
	// "github.com/davecgh/go-spew/spew"
	"hash/fnv"

	"github.com/getlantern/systray"
	// "github.com/getlantern/systray/example/icon"
	"github.com/skratchdot/open-golang/open"
	"path/filepath"
)

// Exists reports whether the named file or directory exists.
func Exists(name string) bool {
	usr, _ := user.Current()
	// fmt.Println(usr.HomeDir)

	if _, err := os.Stat(usr.HomeDir + name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

func schedule(what func(), delay time.Duration) chan bool {
	stop := make(chan bool)

	go func() {
		for {
			what()
			select {
			case <-time.After(delay):
			case <-stop:
				return
			}
		}
	}()

	return stop
}

func ConfigSet() {
	// fmt.Println("hello?")
	doesFolderExist := Exists("/Documents/MessageBridgeData")
	// fmt.Println(doesFolderExist)
	if doesFolderExist {
		// fmt.Println("Folder Does Exist")

		doesExist := Exists("/Documents/MessageBridgeData/credentials.json")
		if doesExist {
			// fmt.Println("File Does Exist")
			usr, _ := user.Current()
			configBaseLoc = usr.HomeDir + "/Documents/MessageBridgeData/"
			configSet = true
			stop <- true

			close(stop)

		} else {

			// fmt.Println("File Doesn't Exist")
		}

	} else {
		usr, _ := user.Current()
		os.Mkdir(usr.HomeDir+"/Documents/MessageBridgeData", 0700)
		fmt.Println("Adding Folder")
		// fmt.Println("Folder Doesn't Exist")
	}

}

var USER_ID string
var BOT_ID string

// var BOT_NAME string
var BOT_TOKEN string
var USER_TOKEN string

var lastText string
var DATE_OFFSET int64
var lastGUID string
var seenMessageGuids = []string{}
var seenMessageGuid = map[string]bool{}

// var baseLoc = "/Users/davidholtz/Desktop/go-message-bridge/dend/"
var baseLoc string
var configBaseLoc string

type configOptions struct {
	// BOT_NAME   string `json:"bot_name"`
	BOT_ID     string `json:"bot_id"`
	USER_ID    string `json:"user_id"`
	BOT_TOKEN  string `json:"bot_token"`
	USER_TOKEN string `json:"user_token"`
}

func getConfig() {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	type Payload struct {
		Text string `json:"text"`
	}

	datap := Payload{
		// fill struct
		configBaseLoc,
	}
	payloadBytes, err := json.Marshal(datap)
	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "https://hooks.slack.com/services/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", body)
	if err != nil {
		// handle err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	plan, _ := ioutil.ReadFile(configBaseLoc + "credentials.json")

	logger.Println(string(plan))
	var data configOptions
	json.Unmarshal([]byte(plan), &data)
	// BOT_NAME = data.BOT_NAME
	BOT_ID = data.BOT_ID
	USER_ID = data.USER_ID
	BOT_TOKEN = data.BOT_TOKEN
	USER_TOKEN = data.USER_TOKEN
}

func hash(s string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(s))
	return h.Sum32()
}

func makeAppleTimestamp() int {
	DATE_OFFSET = 978307200 + 1
	return int((((time.Now().UnixNano()) / int64(time.Millisecond)) / 1000) - DATE_OFFSET)
}

func handleToChannel(handle string) string {
	db, err := bolt.Open(baseLoc+"my.db", 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	var v string
	db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucketIfNotExists([]byte("TEST"))
		if err != nil {
			return err
		}
		v = string(b.Get([]byte(handle)))
		return nil
	})
	defer db.Close()
	return v
}
func setHandleToChannel(handle []byte, channel []byte) {
	db, err := bolt.Open(baseLoc+"my.db", 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucketIfNotExists([]byte("TEST"))
		if err != nil {
			return err
		}
		b.Put(handle, channel)
		return nil
	})
	defer db.Close()
}

func getMessages() {
	args := "?mode=ro&_mutex=no&_journal_mode=WAL&_query_only=1&_synchronous=2"

	usr, err := user.Current()
	if err != nil {
		log.Fatal(err)
	}

	logger.Println(usr.HomeDir)

	connectionString := usr.HomeDir + "/Library/Messages/chat.db" + args
	database, err := sql.Open("sqlite3", connectionString)
	defer database.Close()
	// logger.Println(database)
	if err != nil {
		log.Fatal("Connection Failed ", err)
	}
	// database.Exec("PRAGMA _ignore_check_constraints = 1")
	defer database.Close()

	database.SetMaxOpenConns(1)
	// database.Exec("PRAGMA journal_mode=WAL;")

	rows, qerr := database.Query(`
        SELECT
            guid as id,
            chat_identifier as recipientId,
            service_name as serviceName,
            room_name as roomName,
            display_name as displayName
        FROM chat
        JOIN chat_handle_join ON chat_handle_join.chat_id = chat.ROWID
        JOIN handle ON handle.ROWID = chat_handle_join.handle_id
        ORDER BY handle.rowid DESC
        LIMIT 10;
        `)
	// rows, qerr := database.Query("SELECT name FROM sqlite_master WHERE type='table';")
	defer rows.Close()
	if qerr != nil {
		log.Fatal("Query Failed ", qerr)
	}

	// logger.Println(rows)

	for rows.Next() {
		var id string
		var recipientId string
		var serviceName string
		var roomName string
		var displayName string
		rows.Scan(
			&id,
			&recipientId,
			&serviceName,
			&roomName,
			&displayName,
		)
		logger.Println(
			id,
			recipientId,
			serviceName,
			roomName,
			displayName,
		)
	}
}

func runPoller() {
	ticker := time.NewTicker(1000 * time.Millisecond)
	quit := make(chan struct{})

	go func() {
		for {
			select {
			case <-ticker.C:
				poll()
			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func poll() {
	args := "?mode=ro&_mutex=no&_journal_mode=WAL&_query_only=1&_synchronous=2"
	usr, err := user.Current()
	if err != nil {
		log.Fatal(err)
	}

	// logger.Println(usr.HomeDir)

	connectionString := usr.HomeDir + "/Library/Messages/chat.db" + args
	database, err := sql.Open("sqlite3", connectionString)
	defer database.Close()
	// logger.Println(database)
	if err != nil {
		log.Fatal("Connection Failed ", err)
	}
	// database.Exec("PRAGMA _ignore_check_constraints = 1")
	defer database.Close()

	database.SetMaxOpenConns(1)
	// database.Exec("PRAGMA journal_mode=WAL;")
	latest_ := makeAppleTimestamp()
	latest := strconv.Itoa(latest_ - 1) // time.Now().UTC().String()

	// logger.Println(latest, latest_)
	rows, qerr := database.Query(`
			 SELECT
			    guid,
			    id as handle,
			    handle_id,
			    text,
			    date,
			    date_read,
			    is_from_me,
			    cache_roomnames
			FROM message
			LEFT OUTER JOIN handle ON message.handle_id = handle.ROWID
			WHERE date >= ` + latest + `
        `)
	// rows, qerr := database.Query("SELECT name FROM sqlite_master WHERE type='table';")
	defer rows.Close()
	if qerr != nil {
		log.Fatal("Query Failed ", qerr)
	}

	var guid string
	var handle string
	var handle_id string
	var text string
	var date string
	var date_read string
	var is_from_me string
	var cache_roomnames string

	for rows.Next() {
		rows.Scan(
			&guid,
			&handle,
			&handle_id,
			&text,
			&date,
			&date_read,
			&is_from_me,
			&cache_roomnames,
		)
		if seenMessageGuid[guid] {
		} else {

			logger.Println(handle_id)

			theirChannel := handleToChannel(handle_id)
			var relative_channel string
			if theirChannel != "" {
				relative_channel = theirChannel
			} else {
				// make a new channel
				// userID := handle_id

				// // Make a Regex to say we only want
				// reg, err := regexp.Compile("[^a-zA-Z0-9]+")
				// if err != nil {
				// 	log.Fatal(err)
				// }
				// processedString := reg.ReplaceAllString(handle, "")

				// command := "osascript getContact.applescript " + processedString
				// logger.Println(command)
				// out, exr := exec.Command("sh", "-c", command).Output()
				// if exr != nil {
				// 	log.Fatal(exr)
				// }

				// names := strings.Split(string(out), `\n`)
				// logger.Println(names, len(names))

				pname := string(handle)

				// if len(names) > 0 {
				// 	if len(names[0]) > 4 {
				// 		pname = names[0]
				// 	}
				// }
				logger.Println("Prefered Name: ", pname, len(pname))

				channelID, err := user_API.CreateChannel(pname)
				if err != nil {
					logger.Printf("%s\n", err)
				}
				// take the channel name and handle and add to db
				logger.Println(channelID.ID)

				// auto add the bot to the channel!
				channelID2, errr := user_API.InviteUserToChannel(channelID.ID, BOT_ID)
				if errr != nil {
					logger.Printf("%s\n", errr)
				}

				logger.Println(channelID2)
				logger.Println(handle_id)

				relative_channel = channelID.ID

				setHandleToChannel([]byte(handle_id), []byte(channelID.ID))
				// setHandleToChannel([]byte(pname), []byte(channelID.ID))
				setHandleToChannel([]byte(channelID.ID+"-handle"), []byte(handle))
				// setHandleToChannel([]byte(channelID.ID+"-pname"), []byte(pname))
				// setHandleToChannel([]byte(channelID.ID), []byte(handle_id))
			}

			logger.Println(relative_channel)
			handleToChannel(handle_id)
			// THE PLACE WE GET THE SINGLE GOOD MESSAGE
			// de dep logic here
			if is_from_me == "1" {
				logger.Println(hash(text))
				logger.Println(hash(lastText))
				if hash(text) == hash(lastText) {
					logger.Println("DONT SEND MESSAGE")
					lastText = "reset"

				} else {
					logger.Println("SEND MESSAGE")
					global_rtm_2.SendMessage(global_rtm.NewOutgoingMessage(text, relative_channel))
				}

			} else {
				global_rtm.SendMessage(global_rtm_2.NewOutgoingMessage(text, relative_channel))
				// convo is with handle_id
			}

			logger.Println(guid, handle_id, handle, is_from_me, "\t\t\t\t\t", text, len(seenMessageGuid), len(seenMessageGuids))

			seenMessageGuid[guid] = true
			seenMessageGuids = append(seenMessageGuids, guid)
		}

		if len(seenMessageGuids) > 10 {
			key := seenMessageGuids[0]
			delete(seenMessageGuid, key)
			seenMessageGuids = append(seenMessageGuids[:0], seenMessageGuids[1:]...)
		}
	}
}

var global_rtm *slack.RTM
var global_rtm_2 *slack.RTM
var user_API *slack.Client

var logger *log.Logger
var stop chan bool
var configSet = false

func onReady() {
	ping := func() { ConfigSet() }

	stop = schedule(ping, 500*time.Millisecond)

	var visable = false

	mInstructions := systray.AddMenuItem("Instructions", "Instructions")
	mQuit := systray.AddMenuItem("Exit", "Quit the whole app")

	go func() {
		for {
			select {
			case <-mInstructions.ClickedCh:
				open.Run("https://github.com/drbh/go-message-bridge")

			case <-mQuit.ClickedCh:
				systray.Quit()
				fmt.Println("Quit2 now...")
				return
			}
		}
	}()

	for {
		time.Sleep(800 * time.Millisecond)
		if configSet {
			fmt.Println("Found File")
			break
		} else {
			if visable == false {
				systray.SetTitle("Please Configure App")
				systray.SetTooltip("Setup your credentials please")
				visable = true
			}
			// fmt.Println("Keep Checking")
		}
	}
	fmt.Println("Done")

	// if visable {
	mInstructions.Hide()
	mQuit.Hide()
	// }

	onReadyComplete()

}

func onReadyComplete() {

	// systray.SetIcon(icon.Data)
	systray.SetTitle("Message Bridge")
	systray.SetTooltip("Lantern")
	// mQuitOrig := systray.AddMenuItem("Quit", "Quit the whole app")
	// go func() {
	// 	<-mQuitOrig.ClickedCh
	// 	fmt.Println("Requesting quit")
	// 	systray.Quit()
	// 	fmt.Println("Finished quitting")
	// }()

	// We can manipulate the systray in other goroutines
	go func() {
		// systray.SetIcon(icon.Data)
		systray.SetTitle("Message Bridge")
		systray.SetTooltip("Slack to Messages")
		// mChange := systray.AddMenuItem("Change Me", "Change Me")
		// mChecked := systray.AddMenuItem("Unchecked", "Check Me")
		mEnabled := systray.AddMenuItem("Enabled", "Enabled")
		// systray.AddMenuItem("Ignored", "Ignored")
		mUrl := systray.AddMenuItem("Get Info", "my home")
		mQuit := systray.AddMenuItem("Exit", "Quit the whole app")

		// Sets the icon of a menu item. Only available on Mac.
		// mQuit.SetIcon(icon.Data)

		// systray.AddSeparator()
		// mToggle := systray.AddMenuItem("Toggle", "Toggle the Quit button")
		// shown := true
		for {
			select {
			// case <-mChange.ClickedCh:
			// 	mChange.SetTitle("I've Changed")
			// case <-mChecked.ClickedCh:
			// 	if mChecked.Checked() {
			// 		mChecked.Uncheck()
			// 		mChecked.SetTitle("Unchecked")
			// 	} else {
			// 		mChecked.Check()
			// 		mChecked.SetTitle("Checked")
			// 	}
			case <-mEnabled.ClickedCh:
				mEnabled.SetTitle("Disabled")

				go runApp()
				mEnabled.Disable()
			case <-mUrl.ClickedCh:
				open.Run("https://github.com/drbh/go-message-bridge")
			// case <-mToggle.ClickedCh:
			// 	if shown {
			// 		// mQuitOrig.Hide()
			// 		mEnabled.Hide()
			// 		shown = false
			// 	} else {
			// 		// mQuitOrig.Show()
			// 		mEnabled.Show()
			// 		shown = true
			// 	}
			case <-mQuit.ClickedCh:
				systray.Quit()
				fmt.Println("Quit2 now...")
				return
			}
		}
	}()
}

func main() {
	onExit := func() {
		// fmt.Println("Starting onExit")
		// now := time.Now()
		// ioutil.WriteFile(fmt.Sprintf(`on_exit_%d.txt`, now.UnixNano()), []byte(now.String()), 0644)
		fmt.Println("Finished onExit")
	}
	// Should be called at the very beginning of main().
	systray.Run(onReady, onExit)

}

func runApp() {

	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	dir, errxx := filepath.Abs(filepath.Dir(os.Args[0]))
	if errxx != nil {
		log.Fatal(errxx)
	}
	dir = strings.TrimSuffix(dir, "MacOS")
	// dir = strings.TrimSuffix(dir, "MessageBridge.app/Contents/MacOS")
	// smallDir := strings.TrimSuffix(dir, "MessageBridge.app/Contents/")
	// logger.Println(dir)

	// baseLoc = dir //+ "Resources/"
	// configBaseLoc = smallDir
	baseLoc = dir + "Resources/"

	f, err := os.OpenFile(configBaseLoc+"text.log",
		os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Println(err)
	}
	defer f.Close()

	logger = log.New(f, "prefix", log.LstdFlags)

	logger.Println(dir)

	logger.Println("\n\n\n")
	logger.Println(configBaseLoc)
	logger.Println(baseLoc)
	logger.Println("\n\n\n")

	getConfig()
	runPoller()

	api := slack.New(
		BOT_TOKEN,
		slack.OptionDebug(false),
		slack.OptionLog(log.New(os.Stdout, "slack-bot: ", log.Lshortfile|log.LstdFlags)),
	)

	rtm := api.NewRTM()
	global_rtm = rtm
	go rtm.ManageConnection()

	api2 := slack.New(
		USER_TOKEN,
		slack.OptionDebug(false),
		slack.OptionLog(log.New(os.Stdout, "slack-bot-2: ", log.Lshortfile|log.LstdFlags)),
	)

	rtm2 := api2.NewRTM()
	user_API = api2

	users, _ := user_API.GetUsers()

	// lets fetch the users id and bots id on startup
	for i := 0; i < len(users); i++ {
		// spew.Dump(users[i])

		logger.Println(users[i].Name, users[i].ID, users[i].RealName)

		// if users[i].IsPrimaryOwner && users[i].IsAdmin {
		// 	USER_ID = users[i].ID
		// 	logger.Println("USR: ", USER_ID)
		// }

		// if users[i].Name == BOT_NAME && users[i].IsBot {
		// 	BOT_ID = users[i].ID
		// 	logger.Println("BOT: ", BOT_ID)
		// }

		// logger.Println(users[i].ID, users[i].Name, users[i].IsBot, users[i].IsAdmin, users[i].IsPrimaryOwner)
	}
	logger.Println("USR: ", USER_ID)
	logger.Println("BOT: ", BOT_ID)

	global_rtm_2 = rtm2
	go rtm2.ManageConnection()

	for msg := range rtm2.IncomingEvents {
		logger.Println("-")
		switch ev := msg.Data.(type) {
		case *slack.HelloEvent:
			// Ignore hello

		case *slack.ConnectedEvent:
			logger.Println("Infos:", ev.Info)
			logger.Println("Connection counter:", ev.ConnectionCount)

		case *slack.MessageEvent:
			// aguid := handleToChannel(ev.Channel)
			// logger.Println(aguid)
			handle := handleToChannel(ev.Channel + "-handle")
			logger.Println(handle)
			if ev.Type == "message" {
				if ev.User == USER_ID {
					lastText = ev.Text
					if len(handle) > 1 {
						logger.Println("Should send iMessage to")
						command := "osascript " + baseLoc + "sendMessage.applescript " + handle + " \"" + ev.Text + "\""
						logger.Println(command)
						out, _ := exec.Command("sh", "-c", command).Output()

						logger.Println(out)
					}

				}
			}
			logger.Printf("Message: %v\n", ev)

		case *slack.PresenceChangeEvent:
			logger.Printf("Presence Change: %v\n", ev)

		case *slack.LatencyReport:
			logger.Printf("Current latency: %v\n", ev.Value)

		case *slack.RTMError:
			logger.Printf("Error: %s\n", ev.Error())

		case *slack.InvalidAuthEvent:
			logger.Printf("Invalid credentials")
			return

		default:
			if msg.Type == "connecting" {

			} else {
				// Ignore other events..
				logger.Printf("Unexpected: %v\n", msg.Data)
				// spew.Dump(msg)
				// os.Exit(3)
			}
		}
	}

	for msg := range rtm.IncomingEvents {
		// logger.Print("Event Received: ")
		switch ev := msg.Data.(type) {
		case *slack.HelloEvent:
			// Ignore hello

		case *slack.ConnectedEvent:
			logger.Println("Infos:", ev.Info)
			logger.Println("Connection counter:", ev.ConnectionCount)
			// Replace C2147483705 with your Channel ID
			// rtm.SendMessage(rtm.NewOutgoingMessage("Hello world", "DC7EXT3RT"))

		case *slack.MessageEvent:
			logger.Printf("Message: %v\n", ev)

		case *slack.PresenceChangeEvent:
			logger.Printf("Presence Change: %v\n", ev)

		case *slack.LatencyReport:
			logger.Printf("Current latency: %v\n", ev.Value)

		case *slack.RTMError:
			logger.Printf("Error: %s\n", ev.Error())

		case *slack.InvalidAuthEvent:
			logger.Printf("Invalid credentials")
			return

		default:
			if msg.Type == "connecting" {

			} else {
				// Ignore other events..
				logger.Printf("Unexpected: %v\n", msg.Data)
				// spew.Dump(msg)
				// os.Exit(3)
			}

		}
	}
	time.Sleep(5 * time.Hour)

}
